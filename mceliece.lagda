\documentclass{report}

\usepackage{ar}
\usepackage[bw]{agda}
\usepackage{ifsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{mathabx}
\usepackage{unicode-math}
\usepackage{newunicodechar}

\newunicodechar{Œª}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{‚à∑}{\ensuremath{\mathnormal\Colon}}
\newunicodechar{‚à®}{\ensuremath{\mathnormal\vee}}
\newunicodechar{‚Ñï}{\ensuremath{\mathbb{N}}}
\newunicodechar{‚àà}{\ensuremath{\mathnormal\in}}
\newunicodechar{‚àã}{\ensuremath{\mathnormal\ni}}
\newunicodechar{‚â°}{\ensuremath{\mathnormal\equiv}}
\newunicodechar{‚à∂}{\ensuremath{\mathnormal\colon\!\!}}
\newunicodechar{‚Ñô}{\ensuremath{\mathbb{P}}}
\newunicodechar{ùîΩ}{\ensuremath{\mathbb{F}}}
\newunicodechar{ùïÑ}{\ensuremath{\mathbb{M}}}
\newunicodechar{ùîπ}{\ensuremath{\mathbb{B}}}
\newunicodechar{ŒΩ}{\ensuremath{\nu}}
\newunicodechar{Œº}{\ensuremath{\mu}}
\newunicodechar{‚à∏}{\ensuremath{\mathnormal\dotdiv}}
\newunicodechar{·µá}{\ensuremath{^\mathrm{b}}}
\newunicodechar{‚â•}{\ensuremath{\mathnormal{\geq}}}
\newunicodechar{œï}{\ensuremath{\mathnormal{\phi}}}
\newunicodechar{‚àß}{\ensuremath{\mathnormal{\wedge}}}
\newunicodechar{‚à£}{\ensuremath{\mathnormal{|}}}
\newunicodechar{‚àò}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{‚àÄ}{\ensuremath{\forall}}
\newunicodechar{‚Ñì}{\ensuremath{\ell}}
\newunicodechar{œÉ}{\ensuremath{\sigma}}
\newunicodechar{Œ±}{\ensuremath{\alpha}}
\newunicodechar{‚ÇÅ}{\ensuremath{_1}}
\newunicodechar{‚ÇÇ}{\ensuremath{_2}}
\newunicodechar{‚Çó}{\ensuremath{_\mathsf{l}}}
\newunicodechar{·µ•}{\ensuremath{_\mathsf{v}}}
\newunicodechar{‚Çò}{\ensuremath{_\mathsf{m}}}
\newunicodechar{‚â§}{\ensuremath{\mathnormal{\leq}}}
\newunicodechar{‚çâ}{\ensuremath{‚àò\hspace{-0.455em}\backslash}}
\newunicodechar{‚ÇÄ}{\ensuremath{\mathnormal{_0}}}
\newunicodechar{‚âü}{\ensuremath{\stackrel{?}{=}}}
\newunicodechar{Œ¥}{\ensuremath{\mathnormal{\delta}}}
\newunicodechar{‚áí}{\ensuremath{\mathnormal{\Rightarrow}}}
\newunicodechar{‚â∞}{\ensuremath{\mathnormal{\nleq}}}
\newunicodechar{‚àé}{\ensuremath{\mathnormal{\blacksquare}}}
\newunicodechar{‚ü®}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{‚ü©}{\ensuremath{\mathnormal{\rangle}}}

\newcommand\hashish{cbf1 42fe 1ebd b0b2 87a4 4018 340b 8159 7ef1 3a63 6f5d 76f4 6f48 a080 b2bc d3f1 3922 f0f1 5219 94cc 5e71 fb1f b2d9 d9f8 dd3b ffe6 be32 0056 5cca 21c4 28eb 9de1}

\newcommand\Sym\AgdaSymbol
\newcommand\D\AgdaDatatype
\newcommand\F\AgdaFunction
\newcommand\B\AgdaBound

\newcommand\algoritma[1]{\textsc{#1}}

\title{le me'oi .Agda.\ velcki be la'o glibau.\ Classic MCELIECE .glibau.}
\author{la .varik.\ .VALefor.}

\begin{document}

\maketitle

\tableofcontents

\chapter{le me'oi .disclaimer.}
ni'o le proga cu na zabna je cu na mulno

\chapter{le terfi'i ja co'e}
ni'o ko'a goi la'au le me'oi .Agda.\ velcki be la'o glibau.\ Classic MCELIECE .glibau.\ li'u me'oi .Agda.\ co'e  .i tu'a ko'a cu filri'a lo nu jimpe fi le mu'oi glibau.\ Classic MCELIECE .glibau.

.i la .varik.\ cu mutce le ka ce'u troci lo nu ko'a drani je cu zabna fi la .varik.\ldots kei je nai lo nu ko'a mutce le ka ce'u sutra  .i ku'i la .varik.\ cu na tolnei lo nu da'i ko'a drani ba'e je cu sutra

\chapter{le me'oi .preamble.}
ni'o la'au le me'oi .preamble.\ li'u vasru le .importe ja me'oi .pragma.\ selsku

\begin{code}
{-# OPTIONS --guardedness #-}

open import IO
open import Data.Fin
  renaming (
    _+_ to _+F_
  )
  hiding (
    _‚âü_
  )
open import Data.Vec
  renaming (
    map to map·µ•;
    sum to sum·µ•;
    foldr to foldr·µ•;
    zipWith to zipWith·µ•;
    zip to zip·µ•;
    reverse to reverse·µ•;
    transpose to ‚çâ
  )
open import Function
open import Data.Bool
  hiding (
    _‚âü_;
    T
  )
open import Data.List
  using (
    _‚à∑_;
    List;
    map;
    reverse;
    []
  )
open import Data.Digit
  using (
    toNatDigits
  )
open import Data.Maybe
  renaming (
    map to map‚Çò
  )
open import Data.These
  using (
    These;
    this;
    that;
    these
  )
open import Algebra.Core
open import Data.Product
open import Data.Nat as ‚Ñï
  hiding (
    _‚âü_
  )
open import Data.Nat.DivMod
open import Relation.Nullary
open import Data.Vec.Bounded
  using (
    Vec‚â§
  )
open import Algebra.Structures
open import Data.Nat.Primality
open import Data.Nat.Properties
  using (
    m‚à∏n+n‚â°m
  )
open import Truthbrary.Data.Fin
open import Truthbrary.Record.Eq
  using (
    _‚âü_
  )
open import Relation.Nullary.Decidable
  using (
    isNo
  )
open import Relation.Binary.PropositionalEquality

import Data.Vec.Properties as DVP
\end{code}

\chapter{le vrici}
ni'o la'au le vrici li'u vasru zo'e poi na racli fa lo nu zbasu lo me'oi .chapter.\ poi ke'a xi re vasru ke'a xi pa po'o

\section{la'oi .\F{hWVùîΩ}.}
ni'o la'o zoi.\ \F{hWVùîΩ} \B x .zoi.\ mu'oi glibau.\ HAMMING weight .glibau.\ la'oi .\B x.

\begin{code}
hWVùîΩ : {a b : ‚Ñï} ‚Üí Vec (Fin b) a ‚Üí ‚Ñï
hWVùîΩ = sum·µ• ‚àò map·µ• f
  where
  f : ‚àÄ {a} ‚Üí Fin a ‚Üí ‚Ñï
  f (suc _) = 1
  f zero = 0
\end{code}

\section{la'oi .\F{\_div2\_}.}
ni'o gonai ge la'oi .\B b.\ du li no gi ko'a goi la'o zoi.\ \B a \F{div2} b .zoi.\ du li no gi ko'a dilcu la'oi .\B a.\ la'oi .\B b.

\begin{code}
_div2_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
_ div2 0 = 0
a div2 (suc b) = a div (suc b)
\end{code}

\section{la'oi .\F{f2f}.}
ni'o ganai ge la'oi .\B a.\ ctaipe la'o zoi.\ \F{Fin} \B n .zoi.\ gi djica lo nu pruce fi lo ctaipe be la'o zoi.\ \F{Fin} \B m .zoi.\ gi gonai ge lo selsni be la'oi .\B a.\ cu dubjavmau la'oi .\B m.\ gi ko'a goi la'o zoi.\ \F{f2f} \B a .zoi.\ sinxa la'oi .\B m.\ gi ko'a sinxa lo selsni be la'oi .\B a.

\begin{code}
f2f : {m n : ‚Ñï} ‚Üí Fin m ‚Üí Fin n
f2f = {!!}
\end{code}

\section{la'oi .\F{fùîΩ}.}
ni'o ganai la'oi .\B a.\ ctaipe la'o zoi.\ \F{Fin} \B q .zoi.\ gi la'o zoi.\ \F{fùîΩ} \B f \B a \B b .zoi.\ sinxa lo nacmecrai be la'o zoi.\ \F{from‚Ñï} \F \$ f (\F{to‚Ñï} \B a) \F \$ \F{to‚Ñï} \B b .zoi.\ ce la'oi .\B q.

\begin{code}
fùîΩ : {n : ‚Ñï} ‚Üí (‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï) ‚Üí Fin n ‚Üí Fin n ‚Üí Fin n
fùîΩ f a b = f2f $ from‚Ñï $ f (to‚Ñï a) $ to‚Ñï b
\end{code}

\section{la'oi .\F{resize}.}
ni'o ga jonai ga je ctaipe la'o zoi.\ \B n\ \F{‚Ñï.‚â§}\ \B m\ .zoi.\ gi ko'a goi la'o zoi.\ \F{resize}\ \{\_\}\ \{m\}\ \{n\}\ \B t\ .zoi.\ du la'o zoi.\ \F{drop}\ \F \$\ \B m\ \F ‚à∏\ \B n\ .zoi.\ gi ko'a du la'o zoi.\ \F{\_++\_}\ \F \$\ \F{replicate}\ \B t\ .zoi.

\begin{code}
resize : ‚àÄ {a} ‚Üí {m n : ‚Ñï} ‚Üí {A : Set a}
       ‚Üí A ‚Üí Vec A m ‚Üí Vec A n
resize {_} {m} {n} {A} x xs = xt $ n ‚Ñï.‚â§? m
  where
  coerce : ‚àÄ {a} ‚Üí {A B : Set a} ‚Üí A ‚â° B ‚Üí A ‚Üí B
  coerce refl = id
  xt : Dec (n ‚Ñï.‚â§ m) ‚Üí Vec A n
  xt (yes z) = drop (m ‚à∏ n) $ coc xs
    where
    coc = coerce $ sym $ cong (Vec A) $ m‚à∏n+n‚â°m z
  xt (no z) = coerce (cong (Vec A) bitc) padin
    where
    padin : Vec A $ n ‚à∏ m + m
    padin = replicate {n = n ‚à∏ m} x ++ xs
    bitc : n ‚à∏ m + m ‚â° n
    bitc = m‚à∏n+n‚â°m $ Data.Nat.Properties.‚â∞‚áí‚â• z

  open ‚â°-Reasoning

  -- ni'o la .varik. cu djica ko'a goi lo nu
  -- zoi zoi. resize x xs .zoi. ja zo'e je zo'e cu basti
  -- zoi zoi. xt (yes g) .zoi. je zo'e
  -- .i tu'a la'o zoi. resize x xs .zoi. ja zo'e cu
  -- zmadu tu'a la'o zoi. xt (yes g) .zoi. je zo'e le
  -- ka la .varik. cu jinvi le du'u ce'u sampu kei kei je
  -- le ka la .varik. cu se frili fa lo nu jimpe fi ce'u
  --
  -- .i la .varik. cu jinvi le du'u ko'a se sarcu lo
  -- nu ciksi lo ctaipe be le su'u ga naja ctaipe
  -- lo su'u la'o zoi. m .zoi. dubjavme'a
  -- la'o zoi. n .zoi. gi la'o zoi. resize x xs .zoi.
  -- du la'o zoi. xt (yes g) .zoi. ja zo'e

  flipko : ‚àÄ {a} ‚Üí {A B : Set a}
         ‚Üí (x : A)
         ‚Üí (d : A ‚â° B)
         ‚Üí x ‚â° coerce (sym d) (coerce d x)
  flipko _ refl = refl

  dropis : (g : n ‚Ñï.‚â§ m)
         ‚Üí let v‚â°v = sym $ cong (Vec A) $ m‚à∏n+n‚â°m g in
           let xs' = coerce v‚â°v xs in
           (_‚â°_
             xs
             (coerce
               (cong (Vec A) $ m‚à∏n+n‚â°m g)
               (take (m ‚à∏ n) xs' ++ xt (yes g))))
  dropis g = sym $ begin
    coerce k konk ‚â°‚ü® cong (coerce k) $ DVP.take-drop-id (m ‚à∏ n) xs' ‚ü©
    coerce k xs' ‚â°‚ü® cong (flip coerce xs') $ symref k ‚ü©
    coerce (sym $ sym k) xs' ‚â°‚ü® sym $ flipko xs $ sym k ‚ü©
    xs ‚àé
    where
    k = cong (Vec A) $ m‚à∏n+n‚â°m g
    xs' : Vec A $ m ‚à∏ n + n
    xs' = coerce (sym k) xs
    konk : Vec A $ m ‚à∏ n + n
    konk = take (m ‚à∏ n) xs' ++ xt (yes g)
    symref : ‚àÄ {a} ‚Üí {A B : Set a}
           ‚Üí (t : A ‚â° B)
           ‚Üí t ‚â° sym (sym t)
    symref refl = refl

  takis : (g : ¬¨ (n ‚Ñï.‚â§ m))
        ‚Üí let k = m‚à∏n+n‚â°m $ Data.Nat.Properties.‚â∞‚áí‚â• g in
          let sink = sym $ cong (Vec A) k in
          xs ‚â° drop (n ‚à∏ m) (coerce sink $ xt $ no g)
  takis g = sym $ begin
    drop (n ‚à∏ m) konk ‚â°‚ü® cong (drop $ n ‚à∏ m) konkydus ‚ü©
    drop (n ‚à∏ m) (pad ++ xs) ‚â°‚ü® dropdus pad xs ‚ü©
    xs ‚àé
    where
    pad = replicate x
    k = m‚à∏n+n‚â°m $ Data.Nat.Properties.‚â∞‚áí‚â• g
    konk : Vec A $ n ‚à∏ m + m
    konk = coerce (sym $ cong (Vec A) k) $ xt $ no g
    konkydus : konk ‚â° pad ++ xs
    konkydus = sym $ flipko (pad ++ xs) $ cong (Vec A) k
    dropdus : ‚àÄ {a} ‚Üí {A : Set a} ‚Üí {m n : ‚Ñï}
            ‚Üí (x : Vec A m)
            ‚Üí (z : Vec A n)
            ‚Üí drop (length x) (x ++ z) ‚â° z
    dropdus [] _ = refl
    dropdus (x ‚à∑ xs) = subst (flip _‚â°_ _) (d xs x) ‚àò dropdus xs
      where
      d : ‚àÄ {a} ‚Üí {A : Set a} ‚Üí {m n : ‚Ñï}
        ‚Üí (x : Vec A m)
        ‚Üí {z : Vec A n}
        ‚Üí (e : A)
        ‚Üí (_‚â°_
            (drop (length x) $ x ++ z)
            (drop (length $ e ‚à∑ x) $ e ‚à∑ x ++ z))
      d x {z} e = sym $ DVP.unfold-drop (length x) e $ x ++ z
\end{code}

\chapter{le fancu poi ke'a srana lo porsi be lo'i me'oi .bit.}

\section{la'oi .\F{nbits}.}
ni'o ko'a goi la'o zoi.\ \F{nbits} \B q .zoi.\ vasru lo su'o me'oi .bit.\ poi ke'a pagbu la'oi .\B q.  .i ge le pamoi be ko'a cu traji le ka ce'u me'oi .significant.\ kei le ka ce'u mleca gi le romoi be ko'a cu traji le ka ce'u me'oi .significant.

.i la'oi .\F{nbits}.\ cu simsa la'o zoi.\ \F{Data.Bin.toBits} .zoi.  .i ku'i la'oi .\F{nbits}.\ me'oi .truncate.

\begin{code}
nbits : ‚àÄ {a} ‚Üí ‚Ñï ‚Üí Vec (Fin 2) a
nbits = resize zero ‚àò fromList ‚àò Data.List.map n2f ‚àò toNatDigits 2
  where
  n2f = Œª f ‚Üí if f ‚â°·µá 0 then zero else suc zero
\end{code}

\section{la'oi .\F{b2f}.}
ni'o la'o zoi.\ \F{b2f} \B x .zoi.\ sinxa lo namcu poi ke'a selsni la'oi .\B x.\ noi .endi le me'oi .little.

\begin{code}
b2f : {n : ‚Ñï} ‚Üí Vec (Fin 2) n ‚Üí Fin $ 2 ^ n
b2f {n} = cond ‚àò flip zip·µ• indy ‚àò map·µ• f2f
  where
  -- | ni'o cadga fa lo nu la'oi .zf. du li no
  -- .i ku'i le mu'oi glibau. type checker
  -- .glibau. cu na djuno le du'u ro da poi ke'a
  -- kacna'u zo'u li no mleca lo tenfa be li re
  -- bei da
  zf = {!!}
  cond : Vec (Fin (2 ^ n) √ó Fin (2 ^ n)) n ‚Üí Fin $ 2 ^ n
  cond = foldr·µ• _ (fùîΩ _+_) zf ‚àò map·µ• (uncurry $ fùîΩ _^_)
  indy : Vec (Fin $ 2 ^ n) n
  indy = reverse·µ• $ map·µ• f2f $ allFin n
\end{code}

\section{la'oi .\F{\_‚àßùîπ‚ÑïùîΩ\_}.}
ni'o la'o zoi.\ \B a \F{‚àßùîπ‚ÑïùîΩ} \B b .zoi.\ mu'oi glibau.\ bitwise and .glibau.\ la'oi .\B a.\ la'oi .\B b.

\begin{code}
_‚àßùîπ‚ÑïùîΩ_ : ‚àÄ {a} ‚Üí ‚Ñï ‚Üí Fin a ‚Üí Fin a
_‚àßùîπ‚ÑïùîΩ_ {a!} a b = toFin $ ‚àßùîπ‚ÑïùîΩ' (nbits a) $ nbits $ to‚Ñï b
  where
  andùîΩ : {n : ‚Ñï} ‚Üí Op‚ÇÇ $ Fin $ suc n
  andùîΩ (suc zero) (suc zero) = suc zero
  andùîΩ _ _ = zero
  ‚àßùîπ‚ÑïùîΩ' : ‚àÄ {m n} ‚Üí Op‚ÇÇ $ Vec (Fin $ suc m) n
  ‚àßùîπ‚ÑïùîΩ' = zipWith·µ• andùîΩ
  -- | ni'o narcu'i fa lo nu zmadu la'o zoi. a! .zoi.
  toFin : Vec (Fin 2) a! ‚Üí Fin a!
  toFin = f2f ‚àò b2f
\end{code}

\chapter{la'oi .\D ùïÑ.\ je zo'e}
ni'o la'au la'oi .\D M.\ je zo'e li'u vasru le velcki be ko'a goi la'oi .\D M.\ je le pinka be ko'a be'o je ko'a goi le fancu poi ke'a srana la'oi .\D M.\ po'o ku'o je le pinka be ko'a

\section{la'oi .\D ùïÑ.}
ni'o ro da poi ke'a mu'oi zoi.\ .\D ùïÑ \B a \B b .zoi.\ zo'u da nacmeimei la'oi .\B a.\ la'oi .\B b.

\subsection{le me'oi .field.\ pe'a ru'e}
ni'o ro da poi ke'a me'oi .\D ùïÑ.\ zo'u lo pa moi me'oi .field.\ pe'a ru'e be da cu me'oi .type.\ lo selvau be lo selsni be da

ni'o ro da poi ke'a me'oi .\D ùïÑ.\ zo'u lo re moi me'oi .field.\ pe'a ru'e be da cu ni lo selsni be da cu ganra

ni'o ro da poi ke'a me'oi .\D ùïÑ.\ zo'u lo ci moi me'oi .field.\ pe'a ru'e be da cu ni lo selsni be da cu rajycla

ni'o la'o zoi.\ \F ùïÑ \F ‚Ñï 3 3 \F ‚àã ((1 \F ‚à∑ 2 \F \F ‚à∑ 3 \F ‚à∑ \F{[]}) \F ‚à∑ (4 \F ‚à∑ 5 \F ‚à∑ 6 \F ‚à∑ \F{[]}) \F ‚à∑ (7 \F ‚à∑ 8 \F ‚à∑ 9 \F ‚à∑ \F{[]}) \F ‚à∑ \F{[]}) .zoi.\ du le nacmeimei poi ke'a du la'o cmaci.
\[
	\begin{bmatrix}
		1 & 2 & 3 \\
		4 & 5 & 6 \\
		7 & 8 & 9
	\end{bmatrix}
\]
.cmaci.

\begin{code}
ùïÑ : ‚àÄ {a} ‚Üí Set a ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí Set a
ùïÑ = Vec ‚àò‚ÇÇ Vec
\end{code}

\section{la'oi .\F{ùïÑ!!}.}
ni'o cadga fa lo nu le mu'oi glibau.\ type signature .glibau.\ cu xamgu velcki

\begin{code}
_ùïÑ!!_ : ‚àÄ {a n o} ‚Üí {A : Set a} ‚Üí ùïÑ A n o ‚Üí Fin n ‚Üí Vec A o
_ùïÑ!!_ m n = map·µ• (flip lookup n) m
\end{code}

\section{la'oi .\F{hwùïÑ}.}
ni'o la'o zoi.\ \F{hwùïÑ} \B t .zoi.\ cu sumji be lo'i mu'oi glibau.\ HAMMING weight .glibau.\ be lo'i ro rajypau pe'a ja co'e be la'oi .\B t.

\begin{code}
hwùïÑ : ‚àÄ {a m n} ‚Üí ùïÑ (Fin a) m n ‚Üí ‚Ñï
hwùïÑ = sum·µ• ‚àò map·µ• hWVùîΩ
\end{code}

\section{la'oi .\F{rf}.}
ni'o go la'o zoi.\ \F{rf} \B t \B n .zoi.\ zasti gi mapti le mu'oi glibau.\ reduced row-echelon form .glibau.

\begin{code}
data rf {m n} (q : ùïÑ (Fin 2) m n) : ‚Ñï ‚Üí Set
  where
  radfrq : rf q $ hwùïÑ q
\end{code}

\section{la'oi .\F{moult}.}
ni'o la'o zoi.\ \F{moult}\ \B a\ \B b\ .zoi.\ pilji la'o zoi.\ \B a\ .zoi.\ la'o zoi.\ \B b\ .zoi.

\begin{code}
moult : {m n o : ‚Ñï} ‚Üí ùïÑ (Fin 2) m n ‚Üí Vec (Fin 2) o
      ‚Üí Vec (Fin 2) n
moult = {!!}
\end{code}

\chapter{la'oi .\D{MCParam}.\ je zo'e}
ni'o la'au la'oi .\D{MCParam}.\ je zo'e li'u vasru le velcki be ko'a goi la'oi .\D{MCParam}.\ je le pinka be ko'a be'o je ko'a goi le fancu poi ke'a srana la'oi .\D{MCParam}.\ po'o ku'o je le pinka be ko'a

\section{la'oi .\D{MCParam}.}
ni'o ro da poi ke'a me'oi .\D{MCParam}.\ zo'u da sinxa lo me'oi .parameter.\ be lo mu'oi glibau.\ Classic MCELIECE .glibau.\ co'e

\subsection{le me'oi .field.}

\subsubsection{le vrici je me'oi .field.}
\paragraph{la'oi .\F{MCParam.n}.}
ni'o la'o zoi.\ \F{MCParam.n} \D q .zoi.\ ni lo me'oi .code.\ pe la'o zoi.\ \D q .zoi.\ cu clani

\paragraph{la'oi .\F{MCParam.m}.}
ni'o la'o zoi.\ \F{MCParam.m} \D q .zoi.\ dugri lo ni lo me'oi .field.\ cu barda kei li re

\paragraph{la'oi .\F{MCParam.t}.}
ni'o la'o zoi.\ \F{MCParam.t} \D q .zoi.\ ni me'oi .guarantee.\ le du'u cumki fa lo nu rinka ja gasnu ja zo'e lo nu binxo lo drani

\paragraph{la'oi .\F{MCParam.f}.}
ni'o la'o zoi.\ \F{MCParam.f} \B q .zoi.\ me'oi .monic.\ je me'oi .irreducible.\ cpolynomi'a be fi la'o zoi.\ \F{MCParam.m} \B q .zoi\ldots je cu co'e

\paragraph{la'oi .\F{MCParam.F}.}
ni'o la'o zoi.\ \F{MCParam.F} \B q .zoi.\ me'oi .monic.\ je me'oi .irreducible.\ cpolynomi'a be fi la'o zoi.\ \F{MCParam.t} \B q .zoi\ldots je cu co'e

\paragraph{la'oi .\F{MCParam.k}.}
ni'o la'o zoi.\ \F{MCParam.k} \B q .zoi.\ me'oi .dimension.\ lo me'oi .code.\ pe la'oi .\B q.

\paragraph{la'oi .\F{MCParam.ŒΩ}.}
ni'o la'o zoi.\ \F{MCParam.ŒΩ} \B q .zoi.\ dubjavmau li no je cu dubjavme'a lo sumji be la'o zoi.\ \F{MCParam.k} \B q .zoi.\ bei la'o zoi.\ \F{MCParam.Œº \B q} .zoi.

\paragraph{la'oi .\F{MCParam.ŒΩ}.}
ni'o la'o zoi.\ \F{MCParam.Œº} \B q .zoi.\ dubjavmau li no je cu dubjavme'a la'o zoi.\ \F{MCParam.ŒΩ \B q} .zoi.\ je cu dubjavme'a lo vujnu be la'o zoi.\ \F{MCParam.ŒΩ} \B q .zoi.\ bei la'o zoi.\ \F{MCParam.k} \B q .zoi.

\subsubsection{le me'oi .field.\ poi ke'a srana le mu'oi glibau.\ symmetric cryptography .glibau.}
\paragraph{la'oi .\F{MCParam.‚Ñì}.}
ni'o la'o zoi.\ \F{MCParam.‚Ñì} \B q .zoi.\ ni clani fa lo me'oi .output.\ be la'o zoi.\ \F{MCParam.H} \B q .zoi.\

\paragraph{la'oi .\F{MCParam.H}.}
ni'o la'o zoi.\ \F{MCParam.H} \B q .zoi.\ me'oi .hash.\ fancu

\paragraph{la'oi .\F{MCParam.œÉ‚ÇÅ}.}
ni'o la'o zoi.\ \F{MCParam.œÉ‚ÇÅ} \B q .zoi.\ me'oi .arbitrary.

\paragraph{la'oi .\F{MCParam.œÉ‚ÇÇ}.}
.i la'o zoi.\ \F{MCParam.œÉ‚ÇÇ} \B q .zoi.\ go'i

\paragraph{la'oi .\F{MCParam.G}.}
ni'o la'o zoi.\ \F{MCParam.G} \B q \B x .zoi.\ cu me'oi .pseudorandom.\ poi ke'a goi ko'a zo'u pilno la'oi .\B x.\ lo nu me'oi .calculate.\ ko'a

\paragraph{la'oi .\F{n‚â§q}.\ je la'oi .\F{t‚â•2}.\ je la'oi .\F{ŒΩ‚â•Œº}.\ je la'oi .\F{ŒΩ‚â§Œº+k}.\ je la'oi .\F{œÉ‚ÇÅ‚â•m}.\ je la'oi .\F{œÉ‚ÇÇ‚â•2*m}.\ je la'oi .\F{m*t<n}.}
ni'o la .varik.\ cu jinvi le du'u le se ctaipe cu banzuka

\begin{code}
record MCParam : Set
  where
  field
    m : ‚Ñï
    n : ‚Ñï
    t : ‚Ñï
  q : ‚Ñï
  q = 2 ^ m
  field
    f : Vec (Fin 2) m
    F : Vec (Fin q) t
    ŒΩ : ‚Ñï
    Œº : ‚Ñï
    ‚Ñì : ‚Ñï
    H : ‚Ñï ‚Üí Fin $ 2 ^ ‚Ñì
    œÉ‚ÇÅ : ‚Ñï
    œÉ‚ÇÇ : ‚Ñï
    G : Fin $ 2 ^ ‚Ñì ‚Üí Fin $ 2 ^ (n + œÉ‚ÇÇ * q + œÉ‚ÇÅ * t + ‚Ñì)
  k : ‚Ñï
  k = n ‚à∏ m * t
  n-k : ‚Ñï
  n-k = n ‚à∏ k
  field
    n‚â§q : n ‚Ñï.‚â§ q
    t‚â•2 : t ‚Ñï.‚â• 2
    ŒΩ‚â•Œº : ŒΩ ‚Ñï.‚â• Œº
    ŒΩ‚â§Œº+k : ŒΩ ‚Ñï.‚â§ (Œº ‚Ñï.+ k)
    œÉ‚ÇÅ‚â•m : œÉ‚ÇÅ ‚Ñï.‚â• m
    œÉ‚ÇÇ‚â•2*m : œÉ‚ÇÇ ‚Ñï.‚â• 2 * m
    m*t<n : m * t ‚Ñï.< n
\end{code}


\section{la'oi .\F{Public}.}
ni'o la'o zoi.\ \F{Public} \B q .zoi.\ me'oi .type.\ lo gubni termifckiku pe la'oi .\B q.

\begin{code}
Public : MCParam ‚Üí Set
Public p = ùïÑ (Fin 2) (MCParam.k p) $ MCParam.n-k p
\end{code}

\chapter{la'oi .\D{Private}.\ je zo'e}
ni'o la'au la'oi .\D{Private}.\ je zo'e li'u vasru le velcki be ko'a goi la'oi .\D{Private}.\ je le pinka be ko'a be'o je ko'a goi le fancu poi ke'a srana la'oi .\D{Private}.\ po'o ku'o je le pinka be ko'a

\section{la'oi .\D{Private}.}
ni'o ro da poi ke'a ctaipe la'oi .\D{Private}.\ zo'u da sinxa lo sivni termifckiku pe la'o glibau.\ Classic MCELIECE .glibau.

\subsection{le me'oi .field.}

\paragraph{la'oi .\F{Private.lg}.}
ni'o la'o zoi.\ \F{Private.lg} \B p .zoi.\ nilzilcmi ja zo'e la'o zoi.\ \F{Private.g} \B p .zoi.

\paragraph{la'oi .\F{Private.Œì}.}
ni'o la'o zoi.\ \F{Private.Œì} \B p .zoi.\ lo'i ro cpolinomi'a be fi la'o zoi.\ \F{Private.lg} \B p bei fo ko'a goi la'o zoi.\ \F{Fin} \F \$ \F{Private.q} \B .zoi.\ be'o ku pi'u lo'i ro porsi be fi ko'a be'o poi la'o zoi.\ \F{Private.n} \B p .zoi.\ nilzilcmi ke'a

\paragraph{la'oi .\F{Private.s}.}
ni'o la'o zoi.\ \F{Private.s} \F \$ \D{Private} \B p .zoi.\ liste lo'i samsle je cu se nilzilcmi la'o zoi.\ \F{to‚Ñï} \F \$ \F{MCParam.n} \B p .zoi.

\paragraph{la'oi .\F{Private.g}.}
ni'o la'o zoi.\ \F{Private.g} \B q .zoi.\ cpolinomi'a je cu pa moi lo'i ro selvau be la'o zoi.\ \F{Private.Œì} \B q .zoi.

\paragraph{la'oi .\F{Private.q}.\ je la'oi .\F{Private.n}.}
ni'o la .varik.\ cu na jinvi le du'u sarcu ja xamgu fa lo nu jmina lo clani velcki be la'oi .\F{Private.q}.\ je la'oi .\F{Private.n}.

.i cumki fa lo nu lo me'oi .private.\ co'e cu vasru la'oi .MCq.\ je la'oi .MCn.  .i ku'i lo nu lo me'oi .private.\ co'e cu na vasru la'oi .MCq.\ je la'oi .MCn.\ cu filri'a lo nu ciksi

\begin{code}
record Private (p : MCParam) : Set
  where
  q = MCParam.q p
  n = MCParam.n p
  field
    lg : ‚Ñï
    Œì : Vec (Fin q) lg √ó Vec (Fin q) n
    s : Vec (Fin 2) n
  g = proj‚ÇÅ Œì
\end{code}

\section{la'oi .\F{MatGen}.}
ni'o ga jonai ko'a goi la'o zoi.\ \F{MatGen} \B x .zoi.\ me'oi .\F{just}.\ lo gubni termifckiku poi ke'a mapti la'oi .\B x.\ gi ko'a me'oi .\F{nothing}.

ni'o pilno le mu'oi glibau.\ semi-systematic form .glibau.\ ki'u le su'u ga je la .varik.\ cu djica lo nu mapti lo ro broda cei co'e gi le mu'oi glibau.\ systematic form .glibau.\ cu na mapti lo su'o broda

\begin{code}
MatGen : {p : MCParam} ‚Üí Private p ‚Üí Maybe $ Public p
MatGen {p} _ = map‚Çò toPus $ cyst $ repl H~
  where
  tee = MCParam.t p
  enn = MCParam.n p
  mf = ùïÑ (Fin $ MCParam.q p) tee enn
  mftwom = ùïÑ (Fin 2) (MCParam.m p * tee) enn
  -- | ni'o ro da zo'u da ctaipe la'oi .SemiSysForm.
  -- jo cu srana le mu'oi glibau. semi-systematic form
  -- .glibau.
  SemiSysForm : Set
  SemiSysForm = {!!}
  repl : mf ‚Üí mftwom
  repl = {!!}
  cyst : mftwom ‚Üí Maybe SemiSysForm
  cyst = {!!}
  toPus : SemiSysForm ‚Üí Public p
  toPus = {!!}
  H~ : mf
  H~ = {!!}
\end{code}

\chapter{la'oi .\D{KP}.\ je zo'e}

\section{la'oi .\D{KP}.}
ni'o ro da poi ke'a me'oi .\D{KP}.\ zo'u da sinxa lo mu'oi glibau.\ key pair .glibau.\ pe la'o glibau.\ Classic MCELIECE .glibau.

\subsection{le me'oi .field.}
\paragraph{la'oi .F{KP.pu}.}
ni'o ge ko'a goi la'o zoi.\ \F{KP.pu} \B t .zoi.\ gubni termifckiku gi cadga fa lo nu ko'a mapti la'o zoi.\ \F{KP.pr} \B t .zoi.

\paragraph{la'oi .\F{KP.pr}.}
ni'o ge ko'a goi la'o zoi.\ \F{KP.pr} \B t .zoi.\ sivni termifckiku gi cadga fa lo nu ko'a mapti la'o zoi.\ \F{KP.pr} \B t .zoi.

\begin{code}
record KP (p : MCParam) : Set
  where
  field
    pu : Public p
    pr : Private p
\end{code}

\chapter{le fancu poi lo nu xamgu pilno ke'a cu filri'a lo nu zbasu lo termifckiku}
ni'o la'au le fancu poi ke'a goi ko'a zo'u lo nu xamgu pilno ko'a cu filri'a lo nu zbasu lo termifckiku li'u vasru le velcki be vu'oi le fancu je zo'e vu'o poi ke'a goi ko'a zo'u tu'a ko'a cu filri'a lo nu zbasu lo nu zbasu lo termifckiku

\section{la'oi .\F{FieldOrdering}.}
ni'o la'oi .\F{FieldOrdering}.\ velcki ja co'e ko'a goi la'oi .\algoritma{FieldOrdering}.\ poi ke'a se velcki le selvau be la'o cmene.\ mceliece-20201010.pdf .cmene.\ poi ke'a se me'oi .SHA512.\ zoi zoi.\ \hashish\ .zoi.

\begin{code}
FieldOrdering : {p : MCParam}
              ‚Üí Fin $ MCParam.œÉ‚ÇÇ p * MCParam.q p
              ‚Üí Maybe $ Vec (Fin $ MCParam.q p) $ MCParam.q p
FieldOrdering = {!!}
\end{code}

\section{la'oi .\F{SeededKeyGen}.}
ni'o ge ko'a goi la'o zoi.\ \F{KP.pr} \F \$ \F{SeededKeyGen} \B q \B l .zoi.\ selkra la'oi .\B l.\ je cu mu'oi glibau.\ Classic MCELIECE .glibau.\ sivni bo termifckiku gi la'o zoi.\ \F{KP.pu} \F \$ \F{SeededKeyGen} \B q \B l .zoi.\ cu mapti ko'a

.i ga naja la .varik.\ cu djuno lo du'u ma kau ctaipe lo su'u me'oi .terminate.\ gi lakne fa lo nu la .varik.\ cu co'e ja cu basygau zo'oi .TERMINATING.\ zoi glibau.\ NON\_TERMINATING .glibau.

\subsection{le velcki}
\begin{code}
{-# NON_TERMINATING #-}
SeededKeyGen : (p : MCParam) ‚Üí Fin $ 2 ^ MCParam.‚Ñì p ‚Üí KP p
SeededKeyGen p = proj‚ÇÇ ‚àò proj‚ÇÇ ‚àò SeededKeyGen'
  where
  Vqt = Vec (Fin $ MCParam.q p) $ MCParam.t p
  SeededKeyGen' : Fin $ 2 ^ MCParam.‚Ñì p ‚Üí Public p √ó Vqt √ó KP p
  SeededKeyGen' Œ¥ = foo , g , record {pu = foo; pr = pry}
    where
    E = MCParam.G p Œ¥
    b2f' : {m n : ‚Ñï} ‚Üí Vec (Fin 2) m ‚Üí Fin n
    b2f' = f2f ‚àò b2f
    Œ¥' : Fin $ 2 ^ MCParam.‚Ñì p
    Œ¥' = b2f $ rev $ take (MCParam.‚Ñì p) $ rev themDigits
      where
      rev = Data.Vec.reverse
      themDigits : Vec (Fin 2) $ MCParam.‚Ñì p + {!!}
      themDigits = {!!}
    s : Fin $ MCParam.n p
    s = b2f' themDigits
      where
      themDigits : Vec (Fin 2) $ MCParam.n p
      themDigits = {!!}
    -- | .i cumki fa lo nu cumki fa lo nu la'oi .g.
    -- na me'oi .terminate.
    g : Vqt
    g = fromMaybe retry tird
      where
      retry = proj‚ÇÅ $ proj‚ÇÇ $ SeededKeyGen' Œ¥'
      tird : Maybe Vqt
      tird = {!!}
    pry = {!!}
    foo : Public p
    foo = fromMaybe (proj‚ÇÅ $ SeededKeyGen' Œ¥') $ MatGen pry
\end{code}

\section{la'oi .\F{KeyGen}.}
ni'o ge ko'a goi la'o zoi.\ \F{KP.pr} \F{<\$>} \F{KeyGen} \B q .zoi.\ me'oi .return.\ ko'a goi lo mu'oi glibau.\ Classic MCELIECE .glibau.\ sivni bo termifckiku poi ke'a mapti la'oi .\B q.\ gi la'o zoi.\ \F{KP.pu} \F{<\$>} \F{KeyGen} \B q \B l .zoi.\ me'oi .return.\ lo mu'oi glibau.\ Classic MCELIECE.\ .glibau.\ gubni bo termifckiku poi ke'a mapti ko'a

\subsection{le velcki}

\begin{code}
KeyGen : (p : MCParam) ‚Üí IO $ KP p
KeyGen p = SeededKeyGen p IO.<$> cunso
  where
  cunso = {!!}
\end{code}

\chapter{le fancu poi ke'a goi ko'a zo'u tu'a ko'a cu filri'a lo nu me'oi .encode.\ kei je lo nu me'oi .decode.}

\section{la'oi .\F{Hx}.}
ni'o la'o zoi.\ \F{Hx} \{\B p\} \B T .zoi.\ konkatena lo me'oi .identity.\ nacmeimei la'o zoi.\ \B T .zoi.

\begin{code}
Hx : (p : MCParam)
   ‚Üí Public p
   ‚Üí ùïÑ (Fin 2) (MCParam.n-k p + MCParam.k p) $ MCParam.n-k p
Hx p T = I ‚à£ T
  where
  _‚à£_ : ‚àÄ {a} ‚Üí {A : Set a} ‚Üí {m n p : ‚Ñï}
      ‚Üí ùïÑ A m n ‚Üí ùïÑ A p n ‚Üí ùïÑ A (m + p) n
  _‚à£_ a b = Data.Vec.map (lookup++ a b) $ allFin _
    where
    lookup++ = Œª a b n ‚Üí lookup a n ++ lookup b n
  I : {n : ‚Ñï} ‚Üí ùïÑ (Fin 2) n n
  I = map·µ• f $ allFin _
    where
    f : {n : ‚Ñï} ‚Üí Fin n ‚Üí Vec (Fin 2) n
    f x = updateAt x (const $ suc zero) $ replicate zero
\end{code}

\section{la'oi .\F{Encode}.}
ni'o la'oi .\F{Encode}.\ velcki ja co'e ko'a goi la'oi .\algoritma{Encode}.\ poi ke'a se velcki le selvau be la'o cmene.\ mceliece-20201010.pdf .cmene.\ poi ke'a se me'oi .SHA512.\ zoi zoi.\ \hashish\ .zoi.

\begin{code}
Encode : (p : MCParam)
       ‚Üí (e : Vec (Fin 2) $ MCParam.n p)
       ‚Üí Public p
       ‚Üí {hWVùîΩ e ‚â° MCParam.t p}
       ‚Üí Vec (Fin 2) $ MCParam.n-k p
Encode p e T = moult H e
  where
  H = Hx p T
\end{code}

\section{la'oi .\F{Decode}.}
ni'o la'oi .\F{Decode}.\ velcki ja co'e ko'a goi la'oi .\algoritma{Decode}.\ poi ke'a se velcki le selvau be la'o cmene.\ mceliece-20201010.pdf .cmene.\ poi ke'a se me'oi .SHA512.\ zoi zoi.\ \hashish\ .zoi.  .i la'oi .\F{Decode}.\ cu na prane pe'a le ka ce'u xe fanva ko'a

\begin{code}
Decode : {p : MCParam}
       ‚Üí Vec (Fin 2) $ MCParam.n-k p
       ‚Üí Public p
       ‚Üí (Œ£ ‚Ñï $ Vec $ Fin (MCParam.q p))
       ‚Üí Vec (Fin $ MCParam.q p) $ MCParam.n p
       ‚Üí Maybe $ Vec (Fin 2) $ MCParam.n p
Decode {p} C‚ÇÄ bar (_ , g) Œ±' = e Data.Maybe.>>= map‚Çò proj‚ÇÅ ‚àò mapti?
  where
  xv = Œª f ‚Üí Vec (Fin 2) $ f p
  dist : {n : ‚Ñï} ‚Üí Vec (Fin 2) n ‚Üí Vec (Fin 2) n ‚Üí ‚Ñï
  dist = Vec‚â§.length ‚àò‚ÇÇ filter drata ‚àò‚ÇÇ zip·µ•
    where
    drata = _‚âü_ true ‚àò isNo ‚àò uncurry _‚âü_
  v : xv MCParam.n
  v = zenbyco'e tv C‚ÇÄ $ replicate {n = MCParam.n p} zero
    where
    zenbyco'e : _ ‚Üí _ ‚Üí Vec (Fin 2) _ ‚Üí xv MCParam.n
    zenbyco'e = {!!}
    tv : (Œª t ‚Üí These t t ‚Üí t) $ Fin 2
    tv = Data.These.fold id id const
  sumji : Op‚ÇÇ $ xv MCParam.n
  sumji = zipWith·µ• $ fùîΩ _+_
  c' : Maybe $ Œ£ (xv MCParam.n) $ Œª c ‚Üí dist c v ‚Ñï.‚â§ MCParam.t p
  c' = {!!}
  c = map‚Çò proj‚ÇÅ c'
  e = flip map‚Çò c $ sumji v
  -- | .i lisri
  huck : {m n : ‚Ñï} ‚Üí Vec (Fin m) n ‚Üí ‚Ñï
  huck {m} {n} = Data.List.sum ‚àò pilji ‚àò indice ‚àò toList
    where
    indice = Data.List.zip $ Data.List.upTo n
    pilji = Data.List.map $ Œª (a , b) ‚Üí a * m ^ to‚Ñï b
  mapti : xv MCParam.n ‚Üí Set
  mapti e = (hWVùîΩ e ‚â° MCParam.t p) √ó (C‚ÇÄ ‚â° H*e)
    where
    H*e = moult H e
      where
      H = Hx p bar
  mapti? : xv MCParam.n ‚Üí Maybe $ Œ£ (xv MCParam.n) mapti
  mapti? e with hWVùîΩ e ‚Ñï.‚âü MCParam.t p
  ... | yes x = {!!}
  ... | no _ = nothing
\end{code}
\end{document}
